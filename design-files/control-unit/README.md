# SoT8 Control Unit

The Control Unit is responsible for sequencing all of the steps required
to perform each instruction in the processor.  Each step is merely the
assertion of one or more of the 32 control signals that drive the state
changes in the functional modules.

The Control Unit in the SoT8 is very simple.  It consists of 4 EEPROMs
that map 13 inputs (the opcode, the step number, and carry and condition
flags) to the 32 control signal outputs.  It does this using 3 basic
functional blocks:

* Step Counter
* Instruction Register
* Condition Code (CC) Register and flags logic

Each 28C64 EEPROM drives one bank of 8 control signals, roughly grouped
like so:

* Bank A: ALU signals
* Bank B: General Purpose Register signals
* Bank C: Special Register signals
* Bank D: Memory and miscellaneous control signals

There are 2 external signals that the Control Unit uses:

* `CLK`: The global clock signal from the Clock Module.
* `PROG`: The "program mode" signal from the Memory Module.

`CLK` is used directly by the Instruction Register and the CC Register,
as with all other registers in the processor.  However, because the
address lines of the decode ROM have a setup time and must remain stable
during the global state transitions that happen on the rising edge of
`CLK`, the decode ROM input changes must be offset by a half-cycle.  This
is achieved by inverting `CLK`; the resulting signal, used only within the
Control Unit, is called `uc_clk` (microcode clock).

`PROG` is used to inform the Control Unit that the processor is in
"program mode", and suppresses the advancement of the Step Counter.

In addition to the 32 standard control signals, the Control Unit also
provides an `_RST` signal that is triggered by user input.  Because there
are external modules that snoop the `_ucSR` (microcode Step Reset) signal,
the raw `_XucSR` signal from the decode ROM is combined with `_RST` (using
an AND gate, because both signals are active-low) to produce `_ucSR` so that
those consumers can consume both resets using only one signal.

Each of the 13 address lines (A0-A12) of each 28C64 are connected to the
corresponding line on all the others, forming a single logical 32-bit output.

## Step Counter

The Step Counter is built from a 74HCT161 4-bit counter.  Bits 0-2 of
the output are wired to A0-A2 of the decode ROM.  The counter is wired
up to advance on each `uc_clk` rising edge.  The `_XucSR` signal resets
the counter to 0 by loading the 4 input bits (tied to `GND`).  Each
instruction asserts `_XucSR` in its final step.  The Step Counter also
resets to 0 when `_RST` is asserted.  Microcode steps are referred to
as _S0_ - _S7_.

## Instruction Register

The Instruction Register is built with a 74HCT377, like the General Purpose
registers, but is connected to A3-A10 of the decode ROM using a 74HCT273
that latches the Instruction Register value on the `uc_clk` rising-edge.
The `_IRW` signal enables writing of the Instruction Register.

The Instruction Register is loaded in the first two microcode steps,
which are the same in every instruction slot:

* _S0_: Copy Program Counter to Memory Address Register.
* _S1_: Read memory I-space into Instruction Register, advance PC.

The PC advance is placed in _S1_ because of how "program mode" works;
_S0_ is repeated each time a new value is clocked into I-space when
"program mode" is active, and we don't want the PC to advance when this
happens.

## Condition Code (CC) Register and flags logic

The CC Register is able to take inputs from two sources:

* The ALU, which provides `ALU_C`, `ALU_Z`, `ALU_O`, and `ALU_N` signals.
* The processor bus, providing zero and negative flag inputs.

The CC source is selected using a 74HCT157 4-bit selector; the A inputs are
connected to the bus flags logic, and the B inputs are connected to the
ALU flags signals.  The B inputs are selected when the `ACC` signal is
asserted.

The bus flags logic is fairly simple.  All 8 processor bus data lines are
logically NOR'd together (using 2 4-input NOR gates and an AND gate) to
generate the zero flag, and `BUS_D7` is used directly to generate the negative
flag.

The CC Register latches the value selected when either the `ACC` or `BCC`
signals are asserted.  As with the Instruction Register, a 74HCT273 latches
the value from the CC Register on the `uc_clk` rising edge and provides the
input to the flags logic.

The decode ROM takes two condition inputs: the carry input (A11) and the flag
input (A12).  Carry is reflected directly from the CC latch.  The flag input
is generated by AND'ing each of the zero, overflow, and negative condition
codes with a corresponding bit of the Instruction latch: bit 0 for Z, bit 1
for O, and bit 2 for N; the encoding for instuctions that act upon these
condition codes reflects which code the instruction cares about.  The output
of these AND gates is then OR'd together to form the single flag input to
the decode ROM.

Instructions that wish to act upon these condition codes have two sets
of microcode steps, one to execute when the condition is true, and one
to execute when the condition is false.  These steps are then written to
the corresponding instruction slot selected by the opcode and condition
inputs.  Because instructions can only be conditional on one input at a
time, 2 copies of each set of steps must be written to the decode ROM,
once for each value of the "don't care" condition input.  Regularly encoded
instructions that are not conditional simply have 4 copies of their steps,
one for each value of the two condition inputs.

In addition to being a condition input to the decode ROM, the carry
input is also used by the decode ROM to reflect the carry value into
`ALC` signal for the _adc_ and _sbc_ instructions.
